// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class Refund extends ethereum.Event {
  get params(): Refund__Params {
    return new Refund__Params(this);
  }
}

export class Refund__Params {
  _event: Refund;

  constructor(event: Refund) {
    this._event = event;
  }

  get _from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _value(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class Migrate extends ethereum.Event {
  get params(): Migrate__Params {
    return new Migrate__Params(this);
  }
}

export class Migrate__Params {
  _event: Migrate;

  constructor(event: Migrate) {
    this._event = event;
  }

  get _from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _value(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class MoneyAddedForRefund extends ethereum.Event {
  get params(): MoneyAddedForRefund__Params {
    return new MoneyAddedForRefund__Params(this);
  }
}

export class MoneyAddedForRefund__Params {
  _event: MoneyAddedForRefund;

  constructor(event: MoneyAddedForRefund) {
    this._event = event;
  }

  get _from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _value(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get _total(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get spender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get value(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get value(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class PILLAR extends ethereum.SmartContract {
  static bind(address: Address): PILLAR {
    return new PILLAR("PILLAR", address);
  }

  name(): string {
    let result = super.call("name", "name():(string)", []);

    return result[0].toString();
  }

  try_name(): ethereum.CallResult<string> {
    let result = super.tryCall("name", "name():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  futureSaleVault(): Address {
    let result = super.call(
      "futureSaleVault",
      "futureSaleVault():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_futureSaleVault(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "futureSaleVault",
      "futureSaleVault():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  totalSupply(): BigInt {
    let result = super.call("totalSupply", "totalSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalSupply", "totalSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  maxPresaleTokens(): BigInt {
    let result = super.call(
      "maxPresaleTokens",
      "maxPresaleTokens():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_maxPresaleTokens(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "maxPresaleTokens",
      "maxPresaleTokens():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  numberOfTokensLeft(): BigInt {
    let result = super.call(
      "numberOfTokensLeft",
      "numberOfTokensLeft():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_numberOfTokensLeft(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "numberOfTokensLeft",
      "numberOfTokensLeft():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  decimals(): BigInt {
    let result = super.call("decimals", "decimals():(uint256)", []);

    return result[0].toBigInt();
  }

  try_decimals(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("decimals", "decimals():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  fundingStatus(): boolean {
    let result = super.call("fundingStatus", "fundingStatus():(bool)", []);

    return result[0].toBoolean();
  }

  try_fundingStatus(): ethereum.CallResult<boolean> {
    let result = super.tryCall("fundingStatus", "fundingStatus():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  lockedTeamAllocationTokens(): BigInt {
    let result = super.call(
      "lockedTeamAllocationTokens",
      "lockedTeamAllocationTokens():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_lockedTeamAllocationTokens(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lockedTeamAllocationTokens",
      "lockedTeamAllocationTokens():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  minTokensForSale(): BigInt {
    let result = super.call(
      "minTokensForSale",
      "minTokensForSale():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_minTokensForSale(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "minTokensForSale",
      "minTokensForSale():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  twentyThirtyTokens(): BigInt {
    let result = super.call(
      "twentyThirtyTokens",
      "twentyThirtyTokens():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_twentyThirtyTokens(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "twentyThirtyTokens",
      "twentyThirtyTokens():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  teamAllocation(): Address {
    let result = super.call("teamAllocation", "teamAllocation():(address)", []);

    return result[0].toAddress();
  }

  try_teamAllocation(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "teamAllocation",
      "teamAllocation():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  balanceOf(_owner: Address): BigInt {
    let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(_owner)
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(_owner: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(_owner)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  unlockedTeamStorageVault(): Address {
    let result = super.call(
      "unlockedTeamStorageVault",
      "unlockedTeamStorageVault():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_unlockedTeamStorageVault(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "unlockedTeamStorageVault",
      "unlockedTeamStorageVault():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  tokenPrice(): BigInt {
    let result = super.call("tokenPrice", "tokenPrice():(uint256)", []);

    return result[0].toBigInt();
  }

  try_tokenPrice(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("tokenPrice", "tokenPrice():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  futureTokens(): BigInt {
    let result = super.call("futureTokens", "futureTokens():(uint256)", []);

    return result[0].toBigInt();
  }

  try_futureTokens(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("futureTokens", "futureTokens():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  symbol(): string {
    let result = super.call("symbol", "symbol():(string)", []);

    return result[0].toString();
  }

  try_symbol(): ethereum.CallResult<string> {
    let result = super.tryCall("symbol", "symbol():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  twentyThirtyVault(): Address {
    let result = super.call(
      "twentyThirtyVault",
      "twentyThirtyVault():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_twentyThirtyVault(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "twentyThirtyVault",
      "twentyThirtyVault():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  twentyThirtyAllocation(): Address {
    let result = super.call(
      "twentyThirtyAllocation",
      "twentyThirtyAllocation():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_twentyThirtyAllocation(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "twentyThirtyAllocation",
      "twentyThirtyAllocation():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  unsoldTokens(): Address {
    let result = super.call("unsoldTokens", "unsoldTokens():(address)", []);

    return result[0].toAddress();
  }

  try_unsoldTokens(): ethereum.CallResult<Address> {
    let result = super.tryCall("unsoldTokens", "unsoldTokens():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  unPauseTokenSale(): boolean {
    let result = super.call(
      "unPauseTokenSale",
      "unPauseTokenSale():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_unPauseTokenSale(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "unPauseTokenSale",
      "unPauseTokenSale():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  unlockedTeamAllocationTokens(): BigInt {
    let result = super.call(
      "unlockedTeamAllocationTokens",
      "unlockedTeamAllocationTokens():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_unlockedTeamAllocationTokens(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "unlockedTeamAllocationTokens",
      "unlockedTeamAllocationTokens():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  pillarTokenFactory(): Address {
    let result = super.call(
      "pillarTokenFactory",
      "pillarTokenFactory():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_pillarTokenFactory(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "pillarTokenFactory",
      "pillarTokenFactory():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  allowance(_owner: Address, _spender: Address): BigInt {
    let result = super.call(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(_owner), ethereum.Value.fromAddress(_spender)]
    );

    return result[0].toBigInt();
  }

  try_allowance(
    _owner: Address,
    _spender: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(_owner), ethereum.Value.fromAddress(_spender)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  futureSaleAllocation(): Address {
    let result = super.call(
      "futureSaleAllocation",
      "futureSaleAllocation():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_futureSaleAllocation(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "futureSaleAllocation",
      "futureSaleAllocation():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  totalAvailableForSale(): BigInt {
    let result = super.call(
      "totalAvailableForSale",
      "totalAvailableForSale():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_totalAvailableForSale(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "totalAvailableForSale",
      "totalAvailableForSale():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  startTokenSale(
    _fundingStartBlock: BigInt,
    _fundingStopBlock: BigInt
  ): boolean {
    let result = super.call(
      "startTokenSale",
      "startTokenSale(uint256,uint256):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(_fundingStartBlock),
        ethereum.Value.fromUnsignedBigInt(_fundingStopBlock)
      ]
    );

    return result[0].toBoolean();
  }

  try_startTokenSale(
    _fundingStartBlock: BigInt,
    _fundingStopBlock: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "startTokenSale",
      "startTokenSale(uint256,uint256):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(_fundingStartBlock),
        ethereum.Value.fromUnsignedBigInt(_fundingStopBlock)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  pauseTokenSale(): boolean {
    let result = super.call("pauseTokenSale", "pauseTokenSale():(bool)", []);

    return result[0].toBoolean();
  }

  try_pauseTokenSale(): ethereum.CallResult<boolean> {
    let result = super.tryCall("pauseTokenSale", "pauseTokenSale():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this);
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this);
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get _spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this);
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this);
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get _from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }
}

export class FinalizeCall extends ethereum.Call {
  get inputs(): FinalizeCall__Inputs {
    return new FinalizeCall__Inputs(this);
  }

  get outputs(): FinalizeCall__Outputs {
    return new FinalizeCall__Outputs(this);
  }
}

export class FinalizeCall__Inputs {
  _call: FinalizeCall;

  constructor(call: FinalizeCall) {
    this._call = call;
  }
}

export class FinalizeCall__Outputs {
  _call: FinalizeCall;

  constructor(call: FinalizeCall) {
    this._call = call;
  }
}

export class RefundCall extends ethereum.Call {
  get inputs(): RefundCall__Inputs {
    return new RefundCall__Inputs(this);
  }

  get outputs(): RefundCall__Outputs {
    return new RefundCall__Outputs(this);
  }
}

export class RefundCall__Inputs {
  _call: RefundCall;

  constructor(call: RefundCall) {
    this._call = call;
  }
}

export class RefundCall__Outputs {
  _call: RefundCall;

  constructor(call: RefundCall) {
    this._call = call;
  }
}

export class PurchaseCall extends ethereum.Call {
  get inputs(): PurchaseCall__Inputs {
    return new PurchaseCall__Inputs(this);
  }

  get outputs(): PurchaseCall__Outputs {
    return new PurchaseCall__Outputs(this);
  }
}

export class PurchaseCall__Inputs {
  _call: PurchaseCall;

  constructor(call: PurchaseCall) {
    this._call = call;
  }
}

export class PurchaseCall__Outputs {
  _call: PurchaseCall;

  constructor(call: PurchaseCall) {
    this._call = call;
  }
}

export class AllocateTokensCall extends ethereum.Call {
  get inputs(): AllocateTokensCall__Inputs {
    return new AllocateTokensCall__Inputs(this);
  }

  get outputs(): AllocateTokensCall__Outputs {
    return new AllocateTokensCall__Outputs(this);
  }
}

export class AllocateTokensCall__Inputs {
  _call: AllocateTokensCall;

  constructor(call: AllocateTokensCall) {
    this._call = call;
  }

  get _to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _tokens(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class AllocateTokensCall__Outputs {
  _call: AllocateTokensCall;

  constructor(call: AllocateTokensCall) {
    this._call = call;
  }
}

export class AllocateForRefundCall extends ethereum.Call {
  get inputs(): AllocateForRefundCall__Inputs {
    return new AllocateForRefundCall__Inputs(this);
  }

  get outputs(): AllocateForRefundCall__Outputs {
    return new AllocateForRefundCall__Outputs(this);
  }
}

export class AllocateForRefundCall__Inputs {
  _call: AllocateForRefundCall;

  constructor(call: AllocateForRefundCall) {
    this._call = call;
  }
}

export class AllocateForRefundCall__Outputs {
  _call: AllocateForRefundCall;

  constructor(call: AllocateForRefundCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TransferCall extends ethereum.Call {
  get inputs(): TransferCall__Inputs {
    return new TransferCall__Inputs(this);
  }

  get outputs(): TransferCall__Outputs {
    return new TransferCall__Outputs(this);
  }
}

export class TransferCall__Inputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get _to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class TransferCall__Outputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }
}

export class UnPauseTokenSaleCall extends ethereum.Call {
  get inputs(): UnPauseTokenSaleCall__Inputs {
    return new UnPauseTokenSaleCall__Inputs(this);
  }

  get outputs(): UnPauseTokenSaleCall__Outputs {
    return new UnPauseTokenSaleCall__Outputs(this);
  }
}

export class UnPauseTokenSaleCall__Inputs {
  _call: UnPauseTokenSaleCall;

  constructor(call: UnPauseTokenSaleCall) {
    this._call = call;
  }
}

export class UnPauseTokenSaleCall__Outputs {
  _call: UnPauseTokenSaleCall;

  constructor(call: UnPauseTokenSaleCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class StartTokenSaleCall extends ethereum.Call {
  get inputs(): StartTokenSaleCall__Inputs {
    return new StartTokenSaleCall__Inputs(this);
  }

  get outputs(): StartTokenSaleCall__Outputs {
    return new StartTokenSaleCall__Outputs(this);
  }
}

export class StartTokenSaleCall__Inputs {
  _call: StartTokenSaleCall;

  constructor(call: StartTokenSaleCall) {
    this._call = call;
  }

  get _fundingStartBlock(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _fundingStopBlock(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class StartTokenSaleCall__Outputs {
  _call: StartTokenSaleCall;

  constructor(call: StartTokenSaleCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class PauseTokenSaleCall extends ethereum.Call {
  get inputs(): PauseTokenSaleCall__Inputs {
    return new PauseTokenSaleCall__Inputs(this);
  }

  get outputs(): PauseTokenSaleCall__Outputs {
    return new PauseTokenSaleCall__Outputs(this);
  }
}

export class PauseTokenSaleCall__Inputs {
  _call: PauseTokenSaleCall;

  constructor(call: PauseTokenSaleCall) {
    this._call = call;
  }
}

export class PauseTokenSaleCall__Outputs {
  _call: PauseTokenSaleCall;

  constructor(call: PauseTokenSaleCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}
